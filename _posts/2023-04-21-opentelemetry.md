---
title: "OpenTelemetry in SLATE"
overview: How SLATE uses OpenTelemetry
published: true
permalink: blog/2023-04-21-opentelemetry.html
attribution: Suchandra Thapa
layout: post
type: markdown
tag: draft
---

The SLATE binaries and API server requires a fairly complex environment in order
to build successfully.  In order to provide a standardized build environment that 
can be reproducably used in various contexts, the SLATE project uses a 
containerized environment for development and for building binaries for production 
usage. We'll describe the environment and how we use it in this blog post.

<!--end_excerpt-->

## Background

OpenTelemetry is a collection of tools and SDKs that allow developers to 
instrument their applications in order to collect information about 
how their applications and services are operating and to allow for 
interactions between services to be correlated and combined into a single 
unified record.

We instrumented the SLATE services with OpenTelemetry in order to better 
track user interactions and to help with debugging errors that may occur.

## OpenTelemetry

[OpenTelemetry](https://opentelemetry.io/) in an 
[observability framework](https://opentelemetry.io/docs/concepts/observability-primer/#what-is-observability) 
that encompasses a variety of tools and SDKs that combine to let 
an user's end to end interactions to be recorded even if the interaction spans
multiple services such as web portals, api services, and database calls. 

Generally OpenTelemetry is used by instrumenting applications that then send
telemetry data (traces, metrics, logs) to a collector that stores the data in a 
time series database that is then presented to users in a web frontend.  

### Traces and spans

[Traces](https://opentelemetry.io/docs/concepts/signals/traces/) are the primary metric that 
OpenTelemetry is concerned about.  Traces are intended to record all activity that occur in a single
user interaction.  Traces are usually broken down into atomic units of work called spans.  
A span might be consist of something like a SQL query run against a database or a call to a
microservice or an operation on a storage device.  

Traces are usually generated by a `Trace Provider` that is integrated into a service as a SDK.  There
are trace providers for multiple languages such as Python, C++, Javascript, Java, etc.  In SLATE,
we use  C++ and Python trace providers.  

Trace providers will aggregate spans created in an application and then bundle them into traces.  
The traces are then sent to a collector for further processing.

### Collectors

OpenTelemetry uses collectors to receive and process traces from trace providers.  A
collector provides a centralized location for collecting traces from multiple trace providers and
to combine related traces so that interactions across different services and sources can be associated 
with a single user interaction.  

Collectors can also apply additional processing to traces that it receives and then store processed traces 
in persistent storage. 


### Signoz

SLATE choose to use [Signoz](https://signoz.io/) to handle the duties of storing and presenting traces.  
Signoz is an open source platform for presenting OpenTelemetry data.  Signoz also provides a chart that deploys 
an OpenTelemetry collector and a Clickhouse database to store traces, metrics, and logs.  Signoz also provides
alerting and monitoring of services based on traces received.

## Instrumenting SLATE

### C++

The SLATE api server is written in C++.  In order to instrument this component, we had to use the 
OpenTelemetry C++ SDK and update the server code to generate and send traces.  Although the process 
was a bit tedious, it was relatively straightforward.

The core of the OpenTelemetry code is located in [Telemetry.cpp](https://github.com/slateci/slate-client-server/blob/master/src/Telemetry.cpp).
The `initializeTracer` function is called when the server starts up.  It configures the trace
provider for the api server with the appropriate collector, sampling parameters, and other settings.

### Python

## Adding monitoring

##  Conclusion



